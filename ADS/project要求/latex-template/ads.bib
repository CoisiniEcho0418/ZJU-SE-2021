@inproceedings{adel1962algorithm,
  title={An algorithm for organization of information},
  author={Adel'son-Vel'skii, George M and Landis, Evgenii Mikhailovich},
  booktitle={Doklady Akademii Nauk},
  volume={146},
  number={2},
  pages={263--266},
  year={1962},
  organization={Russian Academy of Sciences}
}
@article{10.1145/3828.3835,
author = {Sleator, Daniel Dominic and Tarjan, Robert Endre},
title = {Self-Adjusting Binary Search Trees},
year = {1985},
issue_date = {July 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {3},
issn = {0004-5411},
url = {https://doi.org/10.1145/3828.3835},
doi = {10.1145/3828.3835},
abstract = {The splay tree, a self-adjusting form of binary search tree, is developed and analyzed. The binary search tree is a data structure for representing tables and lists so that accessing, inserting, and deleting items is easy. On an n-node splay tree, all the standard search tree operations have an amortized time bound of O(log n) per operation, where by “amortized time” is meant the time per operation averaged over a worst-case sequence of operations. Thus splay trees are as efficient as balanced trees when total running time is the measure of interest. In addition, for sufficiently long access sequences, splay trees are as efficient, to within a constant factor, as static optimum search trees. The efficiency of splay trees comes not from an explicit structural constraint, as with balanced trees, but from applying a simple restructuring heuristic, called splaying, whenever the tree is accessed. Extensions of splaying give simplified forms of two other data structures: lexicographic or multidimensional search trees and link/cut trees.},
journal = {J. ACM},
month = {jul},
pages = {652–686},
numpages = {35}
}
@book{10.5555/1614191,
author = {Cormen, Thomas H. and Leiserson, Charles E. and Rivest, Ronald L. and Stein, Clifford},
title = {Introduction to Algorithms, Third Edition},
year = {2009},
isbn = {0262033844},
publisher = {The MIT Press},
edition = {3rd},
abstract = {If you had to buy just one text on algorithms, Introduction to Algorithms is a magnificent choice. The book begins by considering the mathematical foundations of the analysis of algorithms and maintains this mathematical rigor throughout the work. The tools developed in these opening sections are then applied to sorting, data structures, graphs, and a variety of selected algorithms including computational geometry, string algorithms, parallel models of computation, fast Fourier transforms (FFTs), and more. This book's strength lies in its encyclopedic range, clear exposition, and powerful analysis. Pseudo-code explanation of the algorithms coupled with proof of their accuracy makes this book is a great resource on the basic tools used to analyze the performance of algorithms.}
}
@book{10.5555/248735,
author = {Weiss, Mark Allen},
title = {Data Structures and Algorithm Analysis in C (2nd Ed.)},
year = {1996},
isbn = {0201498405},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}
@inproceedings{10.1145/800061.808752,
author = {Sleator, Daniel Dominic and Tarjan, Robert Endre},
title = {Self-Adjusting Binary Trees},
year = {1983},
isbn = {0897910990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800061.808752},
doi = {10.1145/800061.808752},
abstract = {We use the idea of self-adjusting trees to create new, simple data structures for priority queues (which we call heaps) and search trees. Unlike other efficient implementations of these data structures, self-adjusting trees have no balance condition. Instead, whenever the tree is accessed, certain adjustments take place. (In the case of heaps, the adjustment is a sequence of exchanges of children, in the case of search trees the adjustment is a sequence of rotations.) Self-adjusting trees are efficient in an amortized sense: any particular operation may be slow but any sequence of operations must be fast.Self-adjusting trees have two advantages over the corresponding balanced trees in both applications. First, they are simpler to implement because there are fewer cases in the algorithms. Second, they are more storage-efficient because no balance information needs to be stored. Furthermore, a self-adjusting search tree has the remarkable property that its running time (for any sufficiently long sequence of search operations) is within a constant factor of the running time for the same set of searches on any fixed binary tree. It follows that a self-adjusting tree is (up to a constant factor) as fast as the optimal fixed tree for a particular probability distribution of search requests, even though the distribution is unknown.},
booktitle = {Proceedings of the Fifteenth Annual ACM Symposium on Theory of Computing},
pages = {235–245},
numpages = {11},
series = {STOC '83}
}
@book{sanderson_2010, 
title={Introduction to Information Retrieval, Cambridge University Press}, DOI={10.1017/S1351324909005129}, 
author ={Christopher D. Manning, Prabhakar Raghavan, Hinrich Schütze},
isbn = {ISBN-13 978-0-521-86571-5},
journal={Natural Language Engineering}, publisher={Cambridge University Press}, year={2008}}


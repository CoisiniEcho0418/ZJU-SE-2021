*! version 1.3.0  23jun2011
version 11

class _marg_work {
	string	t_name	= ""		// tempnames
	string	t_touse	= ""
	string	t_sub	= ""
	string	t_esub	= ""
	string	t_wvar	= ""
	string	t_marg	= ""
	string	t_at	= ""
	string	t_cr	= ""
	string	t_grp	= ""
	string	t_gmat	= ""
	string	t_phat	= ""
	string	t_dx	= ""
	string	t_dzb	= ""
	string	t_altb	= ""
	string	t_H	= ""

	string	matopt	= ""
	string	FVTImatopt	= ""

	double	esample	= 0

	string	est_cmd	= ""
	string	cmdline	= ""
	string	ZERO	= ""

	double	level	= 0
	string	diopts	= ""

	string	wtype	= ""		// weights
	string	wexp	= ""
	string	wt	= ""

	array	atlist			// at()
	array	atstat
	array	atopt
	array	asbal
	double	atmean		= 0
	double	hasat		= 0
	double	atrows		= 0
	double	noasobs		= 0
	string	atcol0		= ""
	string	atcol1		= ""
	double	has_asbal	= 0
	string	atlegend	= ""
	string	BALVARS		= ""
	string	uatvars		= ""

	string	by	= ""
	string	over	= ""
	string	within	= ""
	double	k_by	= 1
	double	hasby	= 0
	array	bylist

	string	empty	= ""

	string	subpop	= ""

	string	nose		= ""	// VCE
	double	se		= 0
	string	vce		= ""
	string	vcetype		= ""
	string	model_vce	= ""
	string	model_vcetype	= ""
	double	lin		= 0
	string	clustvar	= ""
	string	clopt		= ""
	double	nclust		= 0
	double	is_svy		= 0
	double	npsu		= 0
	double	nstr		= 0
	double	df_r		= 0
	double	npost		= 0
	string	posts		= ""
	string	postw		= ""

	double	nobs	= 0
	double	subnobs	= 0

	array	p			// array of predictions in expression
	string	oexp	= ""		// original expression
	string	gexp	= ""		// generate expression
	double	is_pred	= 0		// indicator: expression is predict
	double	is_xb	= 0		// indicator: expression is xb
	double	eqno	= 0		// equation for xb
	string	plabel	= ""		// var label from predict/xb
	double	numeric	= 0		// indicator: numerical derivatives
	double	offset	= 0		// indicator: offset in xb
	double	force	= 0
	double	e_marginsok = 0

	double	est_chk	= 0
	double	noHmat	= 0

	double	cr_any	= 0		// chainrule
	double	cr_all	= 0
	double	cr_use	= 1
	double	cr_use2	= 0

	array	base			// base level index
	array	mlist			// margin matrix list
	double	k_m	= 0
	double	hasm	= 0
	string	margins	= ""

	string	umargins	= ""

	string	commonopts	= ""

	double	has_contrast	= 0
	string	contrast	= ""
	string  contrastopts	= ""
	double	has_ocontrast	= 0
	string	ocontrast	= ""
	double	has_wcontrast	= 0
	string	wcontrast	= ""
	double	has_atcontrast	= 0
	string	atcontrast	= ""
	double	has_atmargins	= 0

	double	has_pwcompare	= 0
	string	pwcompare	= ""
	string  pwcompareopts	= ""

	string  mc_all		= ""
	string  mc_method	= ""
	string  mcompareopt	= ""

	string	xvars		= ""	// x vars for dy/dx
	string	xovars		= ""
	string	xrevars		= ""
	double	ey		= 0
	double	ex		= 0
	string	fvrestripe	= ""
	string	xvar		= "1"	// current x for dy/dx
	array	dxolist			// (1) original names
	array	dxnlist			// (1) restripe names
	array	dxmlist			// (2) dx term matrices
	array	dxvlist			// (2) dx term varnames
	array	dxbase			// base level index for dx factor
	double	dxhasbase	= 0

	double	partial	= 0

	array	mstat

	string	title	= ""
	string	coefttl	= ""
	string	dydxopt	= ""

	double	post	= 0

	string	saving		= ""
	string	sav_double	= ""
	string	sav_replace	= ""

	double	est_tol	= 1e-7

	double	gen	= 0
	array	phat
	double	first	= 1

	double	h	= 0
	double	scale	= 0
}

program .new
	syntax name(name=tname id="tempname")
	if "`e(b)'" != "matrix" {
		error 301
	}
	if `"`e(marginsnotok)'"' == "_ALL" {
		di as err "margins not appropriate after `e(cmd)'"
		exit 322
	}
	if "`e(cmd)'" == "margins" {
		di as err "margins cannot work with its own posted results"
		exit 322
	}
	.t_name	= "`tname'"
	.t_touse= "`tname'_touse"
	.t_sub	= "`tname'_sub"
	.t_esub	= "`tname'_esub"
	.t_wvar	= "`tname'_wvar"
	.t_marg	= "`tname'_marg"
	.t_at	= "`tname'_at"
	.t_cr	= "`tname'_cr"
	.t_grp	= "`tname'_grp"
	.t_gmat	= "`tname'_gmat"
	.t_phat	= "`tname'_phat"
	.t_dx	= "`tname'_dx"
	.t_dzb	= "`tname'_dzb"
	.t_altb	= "`tname'_altb"
	.t_H	= "`tname'_H"
	local covar `"`e(covariates)'"'
	if "`covar'" == "_NONE" {
		di as err "model contains no indepvars"
		exit 322
	}
	local k : list sizeof covar
	if `k' {
		matrix `.t_altb' = J(1,`k',0)
		capture {
			matrix colna `.t_altb' = `covar'
		}
		if c(rc) {
			capture matrix drop `.t_altb'
			.t_altb = ""
		}
	}
	else	.t_altb = ""
	if `"`.t_altb'"' != "" {
		local margprop `"`e(marginsprop)'"'
		local prop noeb
		if `:list prop in margprop' {
			_ms_op_info `.t_altb'
			if r(tsops) {
				di as err ///
"margins cannot work with time-series operators in `e(cmd)' estimation results"
				exit 322
			}
			.FVTImatopt = `"matrix(`.t_altb')"'
		}
		.matopt = `"matrix(`.t_altb')"'
	}
end

program .destructor
	capture drop `.t_touse'
	capture drop `.t_sub'
	capture drop `.t_esub'
	capture drop `.t_wvar'
	local k = `.mlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.mlist[`i']'
	}
	local k = `.atlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.atlist[`i']'
	}
	capture matrix drop `.t_cr'
	capture drop `.t_grp'
	capture matrix drop `.t_gmat'
	local k = `.phat.arrnels'
	forval i = 1/`k' {
		capture drop `.phat[`i']'
	}
	local k = `.dxmlist.arrnels'
	forval i = 1/`k' {
		capture matrix drop `.dxmlist[`i']'
	}
	if "`.t_dzb'" != "" {
		capture drop `.t_dzb'*
	}
	if "`.t_altb'" != "" {
		capture matrix drop `.t_altb'
	}
	if "`.t_H'" != "" {
		capture matrix drop `.t_H'
	}
	.matopt == ""
	.FVTImatopt == ""
end

program .parse
	.est_cmd = `"`e(cmd)'"'
	.cmdline = `"`e(cmdline)'"'
	.ZERO = `"`0'"'
	syntax [anything] [if] [in] [fw aw iw pw] [,	///
			Level(cilevel)			///
			grand				///
			ATMEANs				///
			ASBALanced			///
			ASOBServed			/// default
			SUBpop(passthru)		///
			by(passthru)			///
			over(passthru)			///
			within(passthru)		///
			EMPTYCells(string)		///
			NOWEIGHTs			///
			NOEsample			///
			post				///
			SAVing(string)			///
			NOSE				///
			VCE(passthru)			///
			NOCHAINrule CHAINrule		///
			chain2				/// NOT DOCUMENTED
			noestimcheck			/// NOT DOCUMENTED
			force				///
			vsquish				///
			PRedict(passthru)		/// -predict- options
			EXPression(string)		///
			numerical			/// NOT DOCUMENTED
			dydx(passthru)			///
			eyex(passthru)			///
			dyex(passthru)			///
			eydx(passthru)			///
			CONTinuous			///
			NOATLegend			///
			MCOMPare(passthru)		///
			CONTRast			///
			CONTRast1(string)		///
			PWCOMPare			///
			PWCOMPare1(string)		///
			ESTIMTOLerance(real 1e-5)	///
			*				/// -at()- options
		]

	if _caller() >= 12 {
		if `estimtolerance' < 0 {
			di as err "invalid estimtolerance() option;"
			di as err "negative values not allowed"
			exit 198
		}
		.est_tol = `estimtolerance'
	}

	if `:length local contrast1' {
		local contrast contrast
	}
	if `:length local pwcompare1' {
		local pwcompare pwcompare
	}
	opts_exclusive "`contrast' `pwcompare'"
	.has_contrast = "`contrast'" != ""
	.has_pwcompare = "`pwcompare'" != ""

	.level	= `level'
	_get_diopts diopts options, `options'
	.diopts = `"`diopts' `vsquish' level(`level')"'

	// check for invalid option combinations
	opts_exclusive `"`weight' `noweights'"'
	opts_exclusive `"`vce' `nose'"'
	opts_exclusive `"`chainrule' `nochainrule' `chain2'"'
	opts_exclusive `"`dydx' `eyex' `dyex' `eydx'"'

	.force	= "`force'" != ""
	.wtype	= "`weight'"
	.wexp	= "`exp'"
	.est_chk= "`estimcheck'" == ""
	if `.est_chk' {
		_get_hmat `.t_H'
		if r(rc) {
			.t_H = ""
			.noHmat = 1
			.est_chk = 0
		}
	}

	// parse the multiple -at()- options
	.atlegend = "`noatlegend'"
	.atmean	= "`atmeans'" != ""
	opts_exclusive "`asbalanced' `asobserved'"
	._parse_at, `asbalanced' `options'
	._parse_emptycells, `emptycells'

	// multiple subpopulations
	opts_exclusive "`by' `over'"
	._parse_by, `by' `over' `within'

	if "`.empty'" == "" {
		.empty = "strict"
	}

	// managing the results
	.post	= "`post'" != ""
	.saving	= "`saving'"

	// the -vce()- option
	.nose	= "`nose'"
	.se	= `:length local nose' == 0
	._parse_vce, `vce'

	if `.is_svy' {
		if `:length local noweights' {
			di as err "{p}" ///
"option noweights not allowed with vce(unconditional) " ///
"and svy estimation results{p_end}"
			exit 198
		}
		._check_svyset
		local esubpop "`e(subpop)'"
	}

	if !`:length local noweights' {
		if `"`.wtype'"' == "" {
			.wtype	= `"`e(wtype)'"'
			.wexp	= `"`e(wexp)'"'
		}
		local weight `"`.wtype'"'
		local exp `"`.wexp'"'
	}
	if `.is_svy' | "`.wtype'" == "iweight" {
		local zero zeroweight
	}

	// estimation sample
	.esample = "`noesample'" == ""
	if `.esample' | "`.vce'" == "unconditional" {
		if `.esample' | !`.force' {
			._check_esample
			quietly gen byte `.t_touse' = e(sample)
		}
		else {
			quietly gen byte `.t_touse' = 1
		}
		local IF : copy local if
		local if
		local IN : copy local in
		local in
		if `"`weight'"' == "" {
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse weights
		}
		if `:length local IF' {
			local if : copy local IF
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse if restriction
		}
		if `:length local IN' {
			local in : copy local IN
			marksample touse, novarlist `zero'
			quietly replace `.t_touse' = 0 if !`touse'
			drop `touse'
			._check_touse in range
		}
		if `.is_svy' {
			svymarkout `.t_touse'
			._check_touse svy settings
		}
		local atvars : colna `.atlist[1]'
		if `:length local esubpop' {
			_svy_subpop `.t_touse' `.t_esub', ///
				subpop(`esubpop')
			._check_touse subpop() option
			if `:length local exp' {
				gettoken EQUAL W : exp
				quietly replace `.t_esub' = 0 if `W' == 0
			}
			tempname subuse
			quietly gen byte `subuse' = `.t_esub'
			markout `subuse' `atvars'
			quietly replace `.t_touse' = 0 if `.t_esub' & !`subuse'
		}
		else {
			.t_esub = ""
			markout `.t_touse' `atvars'
		}
		._check_touse indepvars
	}
	else {
		marksample touse, novarlist `zero'
		rename `touse' `.t_touse'
		if `.is_svy' {
			svymarkout `.t_touse'
		}
		if `:length local esubpop' {
			_svy_subpop `.t_touse' `.t_esub', subpop(`esubpop')
		}
		else {
			.t_esub = ""
		}
		local atvars : colna `.atlist[1]'
		markout `.t_touse' `atvars'
	}

	if `:length local subpop' {
		tempname touse
		quietly gen byte `touse' = `.t_touse'
		_svy_subpop `touse' `.t_sub', `subpop'
		drop `touse'
		.subpop = `"`r(subpop)'"'
	}
	else {
		quietly gen byte `.t_sub' = `.t_touse'
	}

	// weights
	if "`.posts'" != "" {
		tempvar wvar
		svygen post double `wvar'	///
			[`.wtype'`.wexp']	///
			if `.t_touse',		///
			posts(`.posts')		///
			postw(`.postw')
	}
	else if "`.wtype'" != "" {
		tempvar wvar
		quietly gen double `wvar' `.wexp'
	}

	if `:length local wvar' & `:length local zero' {
		quietly replace `.t_sub' = 0 if `wvar' == 0
		if "`.t_esub'" != "" {
			quietly replace `.t_esub' = 0 if `wvar' == 0
		}
	}

	if `:length local by' {
		quietly count if `.t_sub'
		local nsub = r(N)
		markout `.t_sub' `.by'
		quietly count if `.t_sub'
		if `nsub' != r(N) {
			if `:list sizeof by' > 1 {
				local vars "variables"
			}
			else	local vars "variable"
			local nsub = `nsub' - r(N)
			if `nsub' > 1 {
				local obs "observations"
			}
			else	local obs "observation"
			if "`.over'" != "" & "`.within'" != "" {
				local msg "over() or within()"
			}
			else if "`.over'" != "" {
				local msg "over()"
			}
			else {
				local msg "within()"
			}
			di as txt "{p 0 7}(note: " ///
"`nsub' `obs' dropped because of missing values in `msg' `vars')" ///
			"{p_end}"
		}
	}

	quietly count if `.t_sub'
	if r(N) == 0 {
		error 2000
	}
	if "`.wtype'" == "fweight" {
		._check_fweight
		sum `.t_touse' [`.wtype'`.wexp'] if `.t_touse', mean
		.nobs = r(sum_w)
		sum `.t_sub' [`.wtype'`.wexp'] if `.t_sub', mean
		.subnobs = r(sum_w)
	}
	else {
		quietly count if `.t_touse'
		.nobs	= r(N)
		quietly count if `.t_sub'
		.subnobs= r(N)
	}

	if `:length local wvar' {
		rename `wvar' `.t_wvar'
		if inlist("`.wtype'", "", "pweight") {
			.wt = "[iweight=`.t_wvar']"
		}
		else {
			.wt = "[`.wtype'=`.t_wvar']"
		}
	}

	local margprop `"`e(marginsprop)'"'
	local prop nochainrule
	if `:list prop in margprop' {
		local nochainrule nochainrule
	}

	if "`.t_altb'" == "" {
		// determine chainrule status for partial derivatives
		_ms_chainrule b if `.t_sub', eclass
		.cr_any	= r(any)
		.cr_all	= r(all)
		matrix `.t_cr' = r(chainrule)
		if !`.cr_any' {
			.cr_use = 0
		}
	}
	else {
		local nochainrule nochainrule
		local numerical numerical
	}

	// parse the prediction expression
	if `:length local numerical' {
		.numeric = 1
	}
	if `:length local expression' {
		opts_exclusive "expression() `predict'"
		._parse_expression `expression'
		if !`:length local chainrule' & !`:length local chain2' {
			local nochainrule nochainrule
		}
	}
	else {
		._parse_expression `predict'
	}

	if `.p.arrnels' == 0 {
		if `:length local chainrule' {
			di as err "option chainrule not allowed"
			exit 198
		}
		if `:length local chain2' {
			di as err "option chain2 not allowed"
			exit 198
		}
		local nochainrule nochainrule
	}
	else if `:length local chainrule' | `:length local chain2' {
		local nochainrule
	}
	if "`nochainrule'" != "" {
		.cr_use = 0
	}
	else if `:length local chain2' & `.cr_any' {
		.cr_use2 = 1
	}

	// parse marginal effects and elasticities
	._parse_dydx, `dydx' `eyex' `dyex' `eydx' `continuous'

	// determine the margins at which to do our calculations
	local grand : length local grand
	if `:length local anything' {
		.hasm = 1
		._parse_margins `anything'
	}
	else {
		local grand 1
	}

	_get_mcompare margins, `mcompare'
	.mc_method	= `"`s(method)'"'
	.mc_all		= `"`s(adjustall)'"'
	.mcompareopt	= `"mcompare(`s(method)' `s(adjustall)')"'

	if `.has_contrast' {
		._parse_contrast_opts, `contrast1'
	}
	if `.has_pwcompare' {
		._parse_pwcompare_opts, `pwcompare1'
	}
	if `grand' {
		local i = `.mlist.arrnels' + 1
		local margi "`.t_marg'`i'"
		.mlist[`i'] = "`margi'"
		matrix `margi' = 1
		matrix colna `margi' = _cons
	}

	._check_by_and_at
	._check_exp if `.t_sub' `.wt', `nose'

	if `"`.xvars'"' == "" {
		if `.noasobs' {
			.title	= "Adjusted predictions"
		}
		else {
			.title	= "Predictive margins"
		}
	}
	else {
		if `.noasobs' {
			.title	= "Conditional marginal effects"
		}
		else {
			.title	= "Average marginal effects"
		}
	}
	if `:length local saving' {
		_prefix_saving `saving'
		.saving		= "`s(filename)'"
		.sav_double	= "`s(double)'"
		.sav_replace	= "`s(replace)'"
	}
end

program .compute, rclass
	syntax [if] [fw aw iw pw] [, check GENerate(name) replace next]

	local ln0 0
	local check : length local check
	local next : length local next
	if `next' {
		local next = `.gen'
	}
	tempname t
	local n = `.p.arrnels'
	if `n' {
		local y `.p[1].varname'
	}
	else {
		tempname y
		quietly gen double `y' = . in 1
	}
	local gen : length local generate
	if `gen' {
		if !`:length local replace' {
			confirm new var `generate'
		}
	}
	if `.is_xb' & ! `.numeric' {
		_ms_means b `if' [`weight'`exp'], eclass fill0 `.p[1].eq'
		matrix `t' = r(means)
		return matrix db `t'
		return scalar constant = 0
		if `gen' | `next' | `.offset' | `.ey' | `.ex' | `.first' {
			.p[1].Predict `if'
			if `.ey' {
				if !`check' {
					capture assert `y' > 0
					local ln0 = c(rc) != 0
				}
				quietly replace `y' = ln(`y')
				if `check' {
					quietly replace `y' = 0 if missing(`y')
				}
			}
			if `.ex' {
				quietly replace `y' = `.xvar'*`y'
			}
			sum `y' `if' [`weight'`exp'], mean
			return scalar b = r(mean)
			return scalar N = r(N)
		}
		else {
			matrix `t' = return(db)*e(b)'
			return scalar b = `t'[1,1]
			return scalar N = r(N)
		}
	}
	else if `.is_pred' {
		.p[1].Predict `if'
		if `.ey' {
			if !`check' {
				capture assert `y' > 0
				local ln0 = c(rc) != 0
			}
			quietly replace `y' = ln(`y')
			if `check' {
				quietly replace `y' = 0 if missing(`y')
			}
		}
		if `.ex' {
			quietly replace `y' = `.xvar'*`y'
		}
		sum `y' `if' [`weight'`exp'], mean
		return scalar b = r(mean)
		return scalar N = r(N)
		return scalar constant = r(max) == r(min)
	}
	else {
		forval i = 1/`n' {
			.p[`i'].Predict `if'
		}
		quietly replace `y' = `.gexp' `if'
		if `.ey' {
			capture assert `y' > 0
			if c(rc) {
				local ln0 = c(rc) != 0
			}
			quietly replace `y' = ln(`y')
			if `check' {
				quietly replace `y' = 0 if missing(`y')
			}
		}
		if `.ex' {
			quietly replace `y' = `.xvar'*`y'
		}
		sum `y' `if' [`weight'`exp'], mean
		return scalar b = r(mean)
		return scalar N = r(N)
		return scalar constant = r(max) == r(min)
	}
	if `ln0' & !`check' {
		return scalar b = .
	}
	if `.first' {
		if `.is_pred' {
			.plabel = "`:variable label `y''"
		}
		.first = 0
	}
	if `next' {
		if `gen' {
			.copyvar `y', next
		}
		else {
			.copyvar `y', next rename
		}
	}
	if `gen' {
		capture drop `generate'
		rename `y' `generate'
	}
end

program .estimate, rclass
	tempname b err nobs

	local EBCOLNA : colf e(b)
	if `.hasby' {
		._make_group
	}
	._fill_at
	._setup_contrast
	._setup_pwcompare

	preserve, changed
	if `.se' {
		tempname J V
	}

	local xvars `.xvars'
	local revar : length local xvars
	if `revar' {
		tempname ehold
		local notfvlist
		local oldname
		local kk 0
		foreach x of local xvars {
			_ms_parse_parts `x'
			if r(type) == "variable" {
				local ++kk
				local xvars`kk' `x'
				if "`r(ts_op)'" != "" {
					local tsopvars `tsopvars' `x'
					local tsbavars `tsbavars' `r(name)'
				}
				local oldname
			}
			else {
				local name `r(ts_op)'.`r(name)'
				if "`name'" != "`oldname'" {
					local ++kk
					local oldname : copy local name
					if "`r(ts_op)'" != "" {
					    local tsopvars `tsopvars' `x'
					    local tsbavars `tsbavars' `r(name)'
					}
				}
				local xvars`kk' `xvars`kk'' `x'
			}
		}
		local k_xterms = `kk'
	}
	else {
		local k_xterms 1
		local xvars _cons
	}

	local k_mstat	= `.mstat.arrnels'

	forval j = 1/`k_xterms' {
		if `revar' {
			if `j' > 1 {
				_est unhold `ehold'
			}
			_est hold `ehold', copy restore
			local XVARS : copy local xvars`j'
			if `:list XVARS in tsbavars' {
				local XVAR : copy local XVARS
				local XVARS `XVAR' `tsopvars'
			}
			else	local XVAR
			.xovars = "`XVARS'"
			_fv_term_info `XVARS' if `.t_sub' `.wt',	///
				individuals tsrestripe `.fvrestripe'	///
				`.FVTImatopt'
			local k_terms = r(k_terms)
			local xvars
			local k 0
			.dxolist.Arrdropall
			.dxnlist.Arrdropall
			.dxmlist.Arrdropall
			.dxvlist.Arrdropall
			forval i = 1/`k_terms' {
				local dx `.t_dx'_`i'
				if r(type`i') == "variable" {
					gettoken x XVARS : XVARS
					local ++k
					.dxolist[`k'] = "`x'"
					matrix `dx' = r(mean`i')
					local x : colna `dx'
					local xvars `xvars' `x'
					.dxnlist[`k'] = "`x'"
				}
				else {
					matrix `dx' = r(level`i')
					.dxbase[`i'] = "`r(base`i')'"
					.dxhasbase = 1
					local r = rowsof(`dx')
					local x : colna `dx'
					forval kk = 1/`r' {
						gettoken x XVARS : XVARS
						local ++k
						.dxolist[`k'] = "`x'"
						local x : colna `dx'
						local lev = `dx'[`kk',1]
						local x `lev'.`x'
						local xvars `xvars' `x'
						.dxnlist[`k'] = "`x'"
					}
				}
				local x : colna `dx'
				.dxvlist[`i'] = "`x'"
				.dxmlist[`i'] = "`dx'"
			}
			.xrevars = "`xvars'"
			if `:length local XVAR' {
				local xvars : copy local XVAR
			}
		}
		foreach x of local xvars {
			forval i = 1/`k_mstat' {
				.mstat[`i'].check_revar
				.mstat[`i'].estimate `x'

				matrix `b' = nullmat(`b'), r(b)
				matrix `err' = nullmat(`err'), r(error)
				matrix `nobs' = nullmat(`nobs'), r(N)
				if `.se' {
					matrix `J' = nullmat(`J') \ r(db)
				}
			}
		}
	}
	if `"`.xvars'"' != "" {
		if !`.hasby' & `.mlist.arrnels' == 1 {
			local restripe = `"`:colna `.mlist[1]''"' == "_cons"
			if `restripe' {
				local restripe = `.atlist.arrnels' == 1
			}
			if `restripe' {
				local restripe = rowsof(`.atlist[1]') == 1
			}
			if `restripe' {
				local colna : coleq `b'
				matrix coleq `b' = _
				matrix colna `b' = `colna'
			}
		}
	}
	local colna : colful `b'
	matrix coleq `err' = _
	matrix colna `err' = `colna'
	if `.se' {
		matrix roweq `J' = _
		matrix rowna `J' = `colna'
		matrix colna `J' = `EBCOLNA'
		if `.lin' {
			._linearize `b' `J' `V'
		}
		else {
			matrix `V' = `J' * e(V) * `J''
		}
		matrix colna `V' = `colna'
		matrix rowna `V' = `colna'
	}

	// Saved results
	return local title `"`.title'"'
	return scalar N = `.nobs'
	if `"`.subpop'"' != "" {
		return local subpop `"`.subpop'"'
		return scalar N_sub = `.subnobs'
	}
	else if `.subnobs' < `.nobs' {
		return scalar N_sub = `.subnobs'
	}
	return local model_vce	   "`.model_vce'"
	return local model_vcetype "`.model_vcetype'"
	return matrix _N `nobs'
	return matrix b `b'
	return matrix error `err'
	if `.se' {
		return matrix Jacobian	`J'
		return matrix V		`V'
		return local vce	"`.vce'"
		return local vcetype	"`.vcetype'"
		if "`.clustvar'" != "" {
			return local clustvar "`.clustvar'"
			return scalar N_clust = `.nclust'
		}
		if `.is_svy' {
			return local prefix svy
			return scalar N_psu = `.npsu'
			return scalar N_strata = `.nstr'
			return scalar df_r = `.df_r'
			if `.npost' {
				return scalar N_poststrata = `.npost'
			}
		}
	}
	return local margins `"`.margins'"'
	return scalar k_margins = `.k_m'
	if `.is_pred' & `"`.plabel'"' != "" {
		return local predict_label `"`.plabel'"'
	}
	if `"`.oexp'"' != "" {
		return local expression `"`.oexp'"'
	}
	else {
		return local expression `"predict()"'
	}
	if "`.xvars'" != "" {
		return local xvars `"`.xvars'"'
		return local derivatives "`.coefttl'"
		if !`.dxhasbase' {
			return local continuous continuous
		}
	}
	return local by "`.by'"
	return local over "`.over'"
	return local within "`.within'"
	return scalar k_by = `.k_by'
	if `.hasby' {
		forval i = 1/`.k_by' {
			return local by`i' `"`.bylist[`i']'"'
		}
	}
	if `.hasat' | `.has_asbal' {
		tempname at atdim
		local k_at = `.atlist.arrnels'
		matrix `atdim' = J(1,`k_at',.)
		local j 0
		forval k = 1/`k_at' {
			matrix `at' = nullmat(`at') \ `.atlist[`k']'
			local slist `"`.atstat[`k']'"'
			local r = rowsof(`.atlist[`k']')/`.k_by'
			matrix `atdim'[1,`k'] = `r'
			forval i = 1/`r' {
				local ++j
				return local atstats`j' `"`slist'"'
			}
			return hidden local atspec`k' `"`slist'"'
			local atopt `"`.atopt[`k']'"'
			return hidden local atopt`k' `"`:list retok atopt'"'
		}
		local r_at = rowsof(`at')
		if `.hasby' {
			local r_at = `r_at' / `.k_by'
		}
		forval k = 1/`r_at' {
			if `.hasby' {
			    if `r_at' > 1 {
				forval j = 1/`.k_by' {
				    local rstripe `rstripe' ///
				    	`k'._at#`.bylist[`j']'
				}
			    }
			    else {
				forval j = 1/`.k_by' {
				    local rstripe `rstripe' `.bylist[`j']'
				}
			    }
			}
			else {
				local rstripe `rstripe' `k'._at
			}
		}
		matrix rownames `at' = `rstripe'
		return matrix at `at'
		return scalar k_at = `k_at'
		return hidden matrix atdims `atdim'
	}
	else	return scalar k_at = 0
	return local emptycells "`.empty'"
	if `.cr_use' {
		return matrix chainrule `.t_cr'
	}
	return hidden local predict	_no_predict
	return local est_cmd		`"`.est_cmd'"'
	return local est_cmdline	`"`.cmdline'"'
	return local cmdline	`"margins `.ZERO'"'
	return local cmd	"margins"
end

program ._parse_eq_opt, rclass
	syntax [, EQuation(string asis)]

	if `:length local equation' {
		gettoken eq1 rest : equation, parse(",")
		return local eq1 `"eq(`eq1')"'
		if `:length local reest' {
			gettoken comma eq2 : equation, parse(",")
			return local eq2 `"eq(`eq2')"'
		}
	}
	else {
		return local eq1 "eq(#1)"
	}
end

program ._check_est, rclass
	syntax [if] [fw aw iw pw] [, mult(name)]

	local next = `.gen'
	local n = `.p.arrnels'
	if `n' == 0 {
		return scalar not_estimable = 0
		exit
	}

	tempname L LH t

	local margprop `"`e(marginsprop)'"'
	local prop addcons
	local addcons : list prop in margprop

	local opts	eclass		///
			fill0		///
			ignoreomit	///
			allownotfound
	forval i = 1/`n' {
		._parse_eq_opt, `.p[`i'].eq'
		local eq1 `"`r(eq1)'"'
		local eq2 `"`r(eq2)'"'
		_ms_means b `if' [`weight'`exp'], `opts' `eq1'
		matrix `L' = r(means)
		if `"`eq2'"' != "" {
			_ms_means b `if' [`weight'`exp'], `opts' `eq2'
			matrix `L' = `L' + r(means)
		}
		if `:length local mult' {
mata:			st_matrix("`L'", st_matrix("`L'"):*st_matrix("`mult'"))
		}
		if `addcons' {
			_ms_eq_info
			local keq = r(k_eq)
			if `keq' == 1 {
				matrix `L' = `L', 1
			}
			else {
				tempname b hold
				matrix `b' = e(b)
				matrix rename `L' `hold'
				local i0 0
				forval i = 1/`keq' {
				    local i1 = `i0' + r(k`i')
				    local ++i0
				    matrix `L' = nullmat(`L'), ///
				    		`hold'[1,`i0'..`i1']
				    local hc = colnumb(`b', "`r(eq`i')':_cons")

	if missing(`hc') {
		if inlist("eq(#`i')", "`eq1'", "`eq2'") {
			matrix `L' = `L', 1
		}
		else {
			matrix `L' = `L', 0
		}
	}

				    local i0 = `i1'
				}
			}
		}
		matrix `LH' = `L'*`.t_H'
		if mreldif(`L', `LH')  > `.est_tol' {
			capture drop `t'
			quietly gen `t' = 0
			.copyvar `t', next rename
			return scalar b = 0
			matrix `L' = 0*e(b)
			return matrix db `L'
			return scalar not_estimable = 1
			return scalar N = e(N)
			exit
		}
	}
	return scalar not_estimable = 0
end

program .est1
	syntax if [, mult(passthru)]

	if `.est_chk' {
		._check_est `if' `.wt', `mult'
		if r(not_estimable) {
			exit
		}
	}

	if "`.nose'" != "" {
		.compute `if' `.wt'
	}
	else if !`.numeric' {
		.compute `if' `.wt', next
	}
	else if `.cr_use' {
		._est1_db_cr `if' `.wt'
	}
	else {
		._est1_db `if' `.wt'
	}
end

program .est2
	syntax if, xvar(string) [mult(passthru)]

	_ms_parse_parts `xvar'
	if r(type) == "variable" {
		._est2_c `if', xvar(`xvar') `mult'
	}
	else {
		._est2_d `if', xvar(`xvar') `mult'
	}
end

program .get_dx_base, rclass
	syntax varname

	local i = `.dxvlist.arrindexof "`varlist'"'
	if `i' == 0 {
		di as err "`varlist' not found in list of indepvars"
		error 198
	}
	return scalar base = `.dxmlist[`i']'[`.dxbase[`i']',1]
end

program .estimate_and_report, rclass
	tempname b ehold
	.estimate
	matrix `b' = r(b)
	if "`r(V)'" == "matrix" {
		tempname V
		matrix `V' = r(V)
	}
	if !`.post' {
		_est hold `ehold'
	}

break {
capture noisily break {

	._post `b' `V'
	if `"`.saving'"' != "" {
		if !`.post' {
			local mypost post
		}
	}
	if `.has_contrast' {
		contrast `.contrast',	`.diopts'		///
					`.commonopts'		///
					`.contrastopts'		///
					`.mcompareopt'		///
					`.atlegend' `mypost'
		return add
	}
	else if `.has_pwcompare' {
		pwcompare `.pwcompare',	`.diopts'		///
					`.commonopts'		///
					`.pwcompareopts'	///
					`.mcompareopt'		///
					`.atlegend' `mypost'
		return add
	}
	else {
		return add
		if `.dxhasbase' {
			return local b
			matrix `b' = e(b)
			return matrix b `b'
			if "`r(V)"'" == "matrix" {
				return local V
				matrix `V' = e(V)
				return matrix V `V'
			}
		}
		_marg_report,	`.diopts'		///
				`.commonopts'		///
				`.mcompareopt'		///
				`.atlegend'
		return add
	}
	return hidden local u_at_vars `"`.uatvars'"'
	._post_dims
	return hidden local marg_dims `"`e(marg_dims)'"'
	if `"`.saving'"' != "" {
		_marg_save,	saving(`"`.saving'"',	///
					`.sav_double'	///
					`.sav_replace')	///
				level(`.level')		///
				eclass
	}

} // capture noisily break
	local rc = c(rc)

	if !`.post' {
		_est unhold `ehold'
	}

} // break
	exit `rc'
end

program ._post, eclass
	args b V
	local hasv : length local V
	if `hasv' {
		local postv "V=`V'"
	}
	ereturn post `b' `V',	esample(`.t_touse')	///
				findomitted		///
				buildfvinfo		///
				noHmat
	_r2e, noclear xmacros(cmd)
	ereturn hidden local u_at_vars `"`.uatvars'"'
	ereturn local cmd	"margins"
end

program ._post_dims, eclass

	if `"`e(xvars)'"' != "" {
		local extra _deriv
	}

	// mlist -- build the list of margin variables
	if `"`e(margins)'"' != "" {
		_fv_term_info `e(margins)', noc
		local k = r(k_terms)
	}
	else	local k 0
	if `k' > 1 {
		local extra `extra' _term
	}
	forval i = 1/`k' {
		local colna : colna r(level`i')
		local mlist : list mlist | colna
	}
	local mlist : list uniq mlist
	local _CONS _cons
	local mlist : list mlist - _CONS

	// atlist -- build the list of at() variables
	tempname at_skip
	mata: st__marg_dims_check_at()
	if `has_at' {
		local atcolna : colna e(at)
		local extra `extra' _atopt
	}
	local i 0
	foreach at of local atcolna {
		local ++i
		if `at_skip'[1,`i'] {
			continue
		}
		_ms_parse_parts `at'
		local hasrcp = "`r(ts_op)'" != ""
		if `hasrcp' {
			local name at(`r(ts_op)'.`r(name)')
		}
		else {
			local name at(`r(name)')
		}
		if !`:list name in atlist' {
			local atlist `atlist' `name'
		}
	}

	// bylist -- build the list of by variables
	if `"`e(by)'"' != "" {
		local bylist `"`e(by)'"'
	}

	if `.has_pwcompare' {
		local dims _pw0 _pw1 _pw `extra'
	}
	else {
		local dims `mlist' `atlist' `bylist' `extra'
	}
	local dims : list retok dims
	ereturn hidden local marg_dims `"`dims'"'
end

// subroutines for .parse ---------------------------------------------------

program ._parse_at
	syntax [, asbalanced at(string) *]

	if `:length local asbalanced' {
		local fprefix (asbalanced) _factor
		local cprefix (mean)
	}
	else if `.atmean' {
		local fprefix (mean) _factor
	}
	if `.atmean' {
		local cprefix (mean) _continuous
	}

	if `.force' {
		local force force
	}

	local matopt `"`.matopt'"'

	_ms_at_parse `fprefix' `cprefix' `at', ///
		asobserved `matopt' `force'
	if "`r(at)'" == "" {
		di as err "model contains no indepvars"
		exit 322
	}
	local uatvars `"`r(atvars)'"'
	local uatvars : list uniq uatvars
	local k 1
	local mat `.t_at'`k'
	matrix `mat' = r(at)
	.atlist[`k'] = "`mat'"
	.atstat[`k'] = `"`r(statlist)'"'
	.atopt[`k'] = `"`fprefix' `cprefix' `at'"'
	.asbal[`k'] = strmatch("`r(statlist)'", "asbalanced")

	local 0 `", `options'"'
	syntax [, at(string) *]
	while `:length local at' {
		_ms_at_parse `fprefix' `cprefix' `at', ///
			asobserved `matopt' `force'
		local uatvars `"`uatvars' `r(atvars)'"'
		local uatvars : list uniq uatvars
		local ++k
		local mat `.t_at'`k'
		matrix `mat' = r(at)
		.atlist[`k'] = "`mat'"
		.atstat[`k'] = `"`r(statlist)'"'
		.atopt[`k'] = `"`fprefix' `cprefix' `at'"'
		.asbal[`k'] = strmatch("`r(statlist)'", "asbalanced")
		local 0 `", `options'"'
		syntax [, at(string) *]
	}

	if "`.t_altb'" != "" {
		local K = `.asbal.arrnels'
		forval k = 1/`K' {
			if `.asbal[`k']' {
				di as err ///
`"asbalanced not allowed with `e(cmd)' estimation results"'
				exit 322
			}
		}
	}
	.uatvars = `"`uatvars'"'

	syntax [, NULLOP]
end

program	._parse_by
	syntax [,	by(string)	///
			over(string)	///
			within(string)	///
	]

	local spec `by' `over' `within'

	local over `by' `over'
	.ocontrast = `"`over'"'
	_strip_contrast `over', notsops nointeractions opt(over)
	if r(contrast) {
		.has_contrast = 1
		.has_ocontrast = 1
	}
	local varlist `"`r(varlist)'"'
	local over
	foreach var of local varlist {
		local pos = strpos("`var'",".")
		if `pos' {
			local var = substr("`var'", `pos'+1, .)
		}
		local over `over' `var'
	}

	.wcontrast = `"`within'"'
	_strip_contrast `within', notsops nointeractions opt(within)
	if r(contrast) {
		.has_contrast = 1
		.has_wcontrast = 1
	}
	local varlist `"`r(varlist)'"'
	local within
	foreach var of local varlist {
		local pos = strpos("`var'",".")
		if `pos' {
			local var = substr("`var'", `pos'+1,.)
		}
		local within `within' `var'
	}

	// parse the combined specification, just in case there is a conflict
	_strip_contrast `.ocontrast' `.wcontrast'

	local by `over' `within'
	local by : list uniq by
	local within : list uniq within
	local over : list by - within
	.over	= "`over'"
	.within	= "`within'"
	.by	= "`by'"
	if `:length local within' {
		_ms_check_varlist i.(`within')
		if "`.empty'" == "" {
			.empty = "reweight"
		}
	}
	.hasby	= "`by'" != ""
end

program ._parse_emptycells
	capture syntax [, REWeight strict]
	if c(rc) {
		di as err "option emptycells() invalid"
		exit 198
	}
	local empty `reweight' `strict'
	opts_exclusive "`empty'"
	.empty = "`empty'"
end

program ._parse_vce
	_vce_parse, opt(delta svy UNCONDitional): `0'
	local vce "`r(vce)'"
	if "`vce'" == "svy" {
		if `"`e(prefix)'"' != "svy" {
			di as err ///
"option vce(svy) is allowed only with survey estimation results"
			exit 322
		}
		local vce unconditional
	}
	.model_vce = "`e(vce)'"
	.model_vcetype = "`e(vcetype)'"
	if `"`.model_vcetype'"' == "HAC" {
		.model_vcetype = "`e(vcetype)' `e(hac_kernel)' `e(hac_lag)'"
	}
	if "`vce'" == "unconditional" {
		if `"`e(prefix)'"' == "svy" {
			.model_vce = "svy"
		}
		if "`.model_vce'" == "svy" {
			if `"`.wtype'"' != "" {
				di as err ///
"weights not allowed with survey estimation results"
				exit 101
			}
			quietly svyset
			if `"`r(settings)'"' == ", clear" {
				di as err ///
"data not set up for svy, use {helpb svyset##|_new:svyset}"
				exit 459
			}
			if "`r(vce)'" == "jackknife" {
				di as err "vce(jackknife) is not supported"
				error 459
			}
			if "`r(vce)'" == "brr" {
				di as err "vce(brr) is not supported"
				error 459
			}
			.posts	= "`r(poststrata)'"
			.postw	= "`r(postweight)'"
			.wtype	= "`r(wtype)'"
			.wexp	= "`r(wexp)'"
		}
		else if "`.model_vce'" == "cluster" {
			.clustvar = "`e(clustvar)'"
			.clopt = "cluster(`e(clustvar)')"
		}
		else if "`.model_vce'" == "robust" {
			if "`e(clustvar)'" != "" {
				.clustvar = "`e(clustvar)'"
			}
			else if "`e(group)'" != "" {
				.clustvar = "`e(group)'"
			}
			if "`.clustvar'" != "" {
				.clopt = "cluster(`.clustvar')"
			}
		}
		else {
			di as err "{p}" ///
"option vce(unconditional) is allowed only after estimation with "	///
"robust, semirobust, or linearized standard errors{p_end}"
			exit 322
		}
	}
	else {
		local vce delta
	}
	.is_svy = "`.model_vce'" == "svy"
	.vce = "`vce'"
	if `.is_svy' {
		.vcetype = "Linearized"
		.lin = 1
	}
	else if inlist("`vce'", "unconditional") {
		.vcetype = "Unconditional"
		.lin = 1
	}
	else {
		.vcetype = "Delta-method"
	}
	if `.lin' {
		._check_vce_not_supported "`e(cmd)'" "`e(cmd2)'"
		.gen = 1
	}
end

program ._check_vce_not_supported
	local cmdlist areg ivreg xtgee xtreg
	local cmd : list 0 & cmdlist
	gettoken cmd : cmd
	if `:length local cmd' {
		di as err ///
`"`cmd' is not supported by margins with the vce(unconditional) option"'
		exit 322
	}
end

program ._check_esample
	quietly count if e(sample)
	if r(N) == 0 {
		di as err "e(sample) does not identify the estimation sample"
		exit 322
	}
	.nobs = r(N)
	if "`.vce'" == "unconditional" {
		if inlist("`.wtype'", "", "aweight", "pweight") {
			if `.nobs' != e(N) {
				local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
				local msg1 ///
"e(sample) does not identify the same number of observations as e(N)"
				if `.force' {
					di as txt `"{p 0 7}(note: "' _c
					di as txt `"`msg0'{break}"' _c
					di as txt `"`msg1'){p_end}"'
				}
				else {
					di as err `"{p}`msg0'{break}"' _c
					di as err `"`msg1'{p_end}"'
					exit 459
				}
			}
		}
	}
end

program ._check_fweight
	if "`.vce'" == "unconditional" {
		sum `.t_touse' [fweight`.wexp'] if e(sample), mean
		if r(sum_w) != e(N) {
			local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
			local msg1 ///
"fweights do not sum to the number of observations posted in e(N)"
			if `.force' {
				di as txt `"{p 0 7}(note: "' _c
				di as txt `"`msg0'{break}"' _c
				di as txt `"`msg1'){p_end}"'
			}
			else {
				di as err `"{p}`msg0'{break}"' _c
				di as err `"`msg1'{p_end}"'
				exit 459
			}
		}
	}
end

program ._check_touse
	if `.esample' & "`.vce'" == "unconditional" {
		local msg0 ///
"unconditional standard errors derived assuming full estimation sample;"
		local msg1 ///
`"`0' dropped observations from the estimation sample"'
		quietly count if `.t_touse'
		if `.nobs' != r(N) {
			if `.force' {
				.nobs = r(N)
				di as txt `"{p 0 7}(note: "' _c
				di as txt `"`msg0'{break}`msg1'){p_end}"'
				exit
			}
			di as err `"{p}`msg0'{break}"' `"`msg1'{p_end}"'
			exit 459
		}
	}
end

program ._check_svy_char
	assert `"`r(`0')'"' == `"`e(`0')'"'
end

program ._check_svyset
	quietly svyset
	capture {
		._check_svy_char stages
		._check_svy_char wtype
		._check_svy_char wexp
		._check_svy_char poststrata
		._check_svy_char postweight
		._check_svy_char singleunit
		local k = e(stages)
		forval i = 1/`k' {
			._check_svy_char su`i'
			._check_svy_char fpc`i'
			._check_svy_char strata`i'
		}
	}
	if c(rc) {
		local msg ///
"svyset characteristics disagree with the svy estimation results"
		if `.force' {
			di as txt "{p 0 7}(note: `msg'){p_end}"
			exit
		}
		di as err "`msg'"
		exit 322
	}
end

program ._parse_expression
	version 11
	local exp : copy local 0
	local i 0
	local oexp : list retokenize exp
	if !`:length local exp' {
		local exp "predict()"
	}
	while `:length local exp' {
		gettoken check exp : exp, /*
			*/ parse(`" "`'~:;,<>\/?!@|#$%^&*()-+=[]{}"') quotes
		if `"`check'"' != "predict" & `"`check'"' != "xb" {
			local gexp `"`gexp'`check'"'
			continue
		}
		gettoken paren : exp, parse(" (")
		if `"`paren'"' != "(" {             /* False alarm */
			local gexp `"`gexp'`check'"'
			continue
		}
		local ++i
		.p[`i'] = ._marg_predict.new
		gettoken args exp : exp, match(par)
		if `"`check'"' == "xb" {
			local args : subinstr local args " " "", all
			local term `"xb(`args')"'
			if `:length local args' {
				local eqopt eq(`args')
			}
			else	local eqopt
			.p[`i'].parse, xb `eqopt'
		}
		else {                     /* check == "predict" */
			local term `"predict(`args')"'
			.p[`i'].parse, `args'
		}
		local gexp `"`gexp'`.p[`i'].varname'"'
	}
	if `.p.arrnels' == 0 {
		di as txt ///
"{p 0 0 2}Warning: expression() does not contain predict() or xb().{p_end}"
	}
	.oexp = `"`oexp'"'
	.gexp = `"`gexp'"'

	if `.p.arrnels' == 1 & `"`.gexp'"' == "`.p[1].varname'" {
		.is_pred = 1
	}
	if `.is_pred' {
		_ms_eq_info
		if `"`.p[1].opts'"' == "xb" {
			.is_xb = !`.p[1].notxb'
		}
		if !`.force' {
			_check_e_margins margins, `.p[1].opts'
			.e_marginsok = r(marginsok)
		}
		.numeric = `.numeric' | !`.is_xb'
		local hasoffset 0
		if `"`.p[1].offset'"' != "nooffset" {
			local coleq : coleq e(b), quote
			local coleq : list clean coleq
			local coleq : list uniq coleq
			local neq : list sizeof coleq
			local hasoffset = strlen("`e(offset)'")
			local done = `hasoffset'
			local i 1
			while !`done' {
				local hasoffset = strlen("`e(offset`i')'")
				local ++i
				local done = `i' > `neq' | `hasoffset'
			}
		}
		.offset = `hasoffset'
	}
	else {
		.numeric = 1
	}
	if `.is_xb' {
		local 0 `", `.p[1].eq'"'
		syntax [, EQuation(string)]
		if substr("`equation'",1,1) == "#" {
			local eqno = substr("`equation'",2,.)
			confirm integer number `eqno'
			.eqno = `eqno'
		}
		else if `:length local equation' {
			local coleq : coleq e(b), quote
			local coleq : list uniq coleq
			local eqno : list posof `"`equation'"' in coleq
			if `eqno' == 0 {
				di as err "equation `equation' not found"
				exit 303
			}
			.eqno = `eqno'
		}
		else {
			.eqno = 1
		}
	}
end

program ._parse_dydx
	syntax [,	dydx(string)		///
			eyex(string)		///
			dyex(string)		///
			eydx(string)		///
			continuous		///
	]

	.ey = "`eyex'" != "" | "`eydx'" != ""
	if `.ey' {
		local ey ey
	}
	.ex = "`eyex'" != "" | "`dyex'" != ""
	if `.ex' {
		local ex ex
	}
	if `:length local continuous' {
		.fvrestripe = "fvrestripe"
	}
	local matopt `"`.matopt'"'
	_ms_dydx_parse `dydx' `eyex' `dyex' `eydx', `ey' `ex' `matopt'
	local xvars "`r(varlist)'"
	if `:list sizeof xvars' {
		if !`.cr_all' {
			.cr_use = 0
		}
	}
	.xvars = "`xvars'"
	.coefttl = cond(`.ey', "ey/", "dy/") + cond(`.ex', "ex", "dx")
	.dydxopt = cond(`.ey', "ey", "dy") + cond(`.ex', "ex", "dx")
	local old
	local k 0
	local note 0
	foreach x of local xvars {
		_ms_parse_parts `x'
		if r(type) == "factor" {
			if `.ex' {
				if `.ey' {
					local opt eyex
				}
				else	local opt dyex
				di as err ///
"factor variables not allowed in option `opt'()"
				exit 198
			}
			local name `r(ts_op)'.`r(name)'
			if `"`name'"' != `"`old'"' {
				if `k' == 1 {
					.fvrestripe = "fvrestripe"
					local ++note
				}
				local old : copy local name
				local k 1
			}
			else {
				local ++k
			}
		}
	}
	if `k' == 1 {
		.fvrestripe = "fvrestripe"
		local ++note
	}
	if `note' & !`:length local continuous' {
		di as txt "{p 0 7}(note: " ///
"continuous option implied because a factor with only one level" ///
" was specified in the `.dydxopt'() option){p_end}"
	}
end

program .get_dx_oname
	args c_dx COLON dx
	local i = `.dxnlist.arrindexof "`dx'"'
	if `i' == 0 {
		di as err "`dx' not found in list of indepvars"
		error 198
	}
	c_local `c_dx' `.dxolist[`i']'
end

program ._parse_margins
	syntax [anything]
	.umargins = `"`anything'"'
	_strip_contrast `anything'
	if r(contrast) {
		.has_contrast = 1
	}
	local varlist `"`r(varlist)'"'
	_fv_term_info `varlist' if `.t_touse' `.wt', noc
	local k = r(k_terms)
	local margins
	forval i = 1/`k' {
		.base[`i'] = r(base`i')
		.mlist[`i'] = "`.t_marg'`i'"
		matrix `.mlist[`i']' = r(level`i')
	}
	.k_m = `k'
	local 0 `"`r(varlist)'"'
	syntax varlist(fv ts)
	.margins = `"`varlist'"'
end

program ._get_common_subopts, sclass
	if `.has_contrast' {
		local noeffects NOEFFects
	}
	syntax [,			///
		CIeffects		///
		PVeffects		///
		`noeffects'		///
		EFFects			///
		SORT			///
		ATEQuations		///
		EQuation(passthru)	///
		post			///
		*			///
	]

	if "`noeffects'" != "" {
		opts_exclusive "`noeffects' `effects'"
		opts_exclusive "`noeffects' `cieffects'"
		opts_exclusive "`noeffects' `pveffects'"
	}
	local effects `cieffects' `pveffects' `effects' `noeffects'

	local equation `equation' `atequations'
	opts_exclusive `"`equation'"'
	if `"`equation'"' == "" {
		local equation atequations
	}

	if `:length local post' {
		.post = 1
	}
	else if `.post' {
		local post post
	}

	local opts `.commonopts' `effects' `sort' `post' `equation'
	local opts : list uniq opts
	.commonopts = `"`opts'"'
	sreturn clear
	sreturn local options `"`options'"'
end

program ._drop_common_subopts, sclass
	local 0 `", `.commonopts'"'
	syntax [, SORT *]
	.commonopts = `"`sort'"'
end

program ._parse_contrast_opts
	capture ._get_common_subopts `0'
	if c(rc) {
		local rc = c(rc)
		di as err "invalid contrast() option;"
		._get_common_subopts `0'
		error `rc'	// [sic]
	}
	local 0 `", `s(options)'"'
	local OPTS	nowald			/// display options
			NOATlevels		///
			lincom			/// other options
			overall			///
			ATjoint			/// margins options
			ATcontrast(string)	///
			OVERjoint		///
			WITHINjoint		///
			noSVYadjust		///
			MARGINSWithin		///
						 // blank
	capture syntax [, `OPTS']
	if c(rc) {
		local rc = c(rc)
		di as err "invalid contrast() option;"
		syntax [, `OPTS']
		error `rc'	// [sic]
	}
	local COPTS `wald' `noatlevels' `lincom' `overall' `svyadjust'
	if `:length local COPTS' {
		.has_contrast = 1
	}
	.contrastopts = "`COPTS'"

	if `:length local atcontrast' {
		local atjoint atjoint
		local ucon = substr(`"`atcontrast'"',1,1) == "{"
		local dot = strpos(`"`atcontrast'"', ".")
		if !(`ucon' | `dot') {
			local atcontrast `atcontrast'._at
		}
		capture _at_strip_contrast `atcontrast', ///
			notsops noint opt(atcontrast)
		if c(rc) {
			local rc = c(rc)
			di as err "invalid atcontrast() suboption;"
			_at_strip_contrast `atcontrast', ///
				notsops noint opt(atcontrast)
			exit `rc'
		}
		local var `"`r(varlist)'"'
		local pos = strpos("`var'",".")
		if `pos' {
			local var = substr("`var'", `pos'+1, .)
		}
		if `"`var'"' != "_at" {
			di as err "invalid atcontrast() suboption;"
			di as err ///
`"{p 0 0 2}`atcontrast' found where '_at' with optional contrast "'	///
"operators expected{p_end}"
			exit 198
		}
		.atcontrast = `"`atcontrast'"'
	}

	if `:length local atjoint' {
		.has_contrast = 1
		.has_atcontrast = 1
	}
	if `:length local overjoint' {
		.has_contrast = 1
		.has_ocontrast = 1
	}
	if `:length local withinjoint' {
		.has_contrast = 1
		.has_wcontrast = 1
	}
	if `:length local marginswithin' {
		.has_atmargins = 1
	}
end

program ._put_sharp, sclass
	while `:length local 0' {
		gettoken spec 0 : 0, parse(" {}")
		if "`spec'" == "{" {
			local result `result'`sharp'`spec'
			while "`spec'" != "}" {
				gettoken spec 0 : 0, parse(" {}")
				if "`spec'" == "" {
					error 198
				}
				local result `result' `spec'
			}
		}
		else {
			local result `result'`sharp'`spec'
		}
		local sharp "#"
	}
	sreturn local result `"`result'"'
end

program ._setup_contrast
	if `.has_contrast' == 0 {
		exit
	}

	local k_at = `.atlist.arrnels'
	if `.atrows' > 1 {
		local atcontrast `"`.atcontrast'"'
		if `:length local atcontrast' == 0 {
			local atcontrast _at
		}
		if `.has_atcontrast' {
			._put_sharp `atcontrast'
			local prefix `"`s(result)'"'
			local sharp0 "#"
		}
		else {
			local postfix "_at"
			local sharp1 "#"
		}
	}

	local at_char
	local ocontrast `"`.ocontrast'"'
	if `:length local ocontrast' {
		if `.has_ocontrast' {
			._put_sharp `ocontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			._put_sharp `ocontrast'
			local postfix `"`postfix'`sharp1'`s(result)'"'
			local sharp1 "#"
			local at_char "@"
		}
	}

	local wcontrast `"`.wcontrast'"'
	if `:length local wcontrast' {
		if `.has_wcontrast' {
			._put_sharp `wcontrast'
			local prefix `"`prefix'`sharp0'`s(result)'"'
			local sharp0 "#"
		}
		else {
			._put_sharp `wcontrast'
			local postfix `"`postfix'`sharp1'`s(result)'"'
			local sharp1 "#"
			if "`at_char'" == "" {
				local at_char "|"
			}
		}
	}

	local umargins `"`.umargins'"'
	if `k_at' {
		local umargins : subinstr local umargins "|" "@", all
		.umargins = `"`umargins'"'
		local at_char "@"
	}
	else if "`at_char'" == "" {
		local at_char "@"
	}
	if `.has_atmargins' {
		if `"`umargins'"' != "" {
			local postfix "(`umargins')`postfix'"
			local umargins
		}
	}
	if `:length local postfix' {
		local postfix "`at_char'`postfix'"
	}
	if `:length local prefix' {
		if `"`umargins'"' == "" {
			.contrast = `"`prefix'`postfix'"'
		}
		else {
			.contrast = `"`prefix'#(`umargins')`postfix'"'
		}
	}
	else if `"`umargins'"' != "" {
		.contrast = `"(`umargins')`postfix'"'
	}
	if `"`.contrast'"' == "" {
		.contrast = `"`umargins'"'
	}
	if `"`.contrast'"' == "" {
		di as txt ///
"{p 0 6 2}note: ignoring contrast options because there are no "	///
"margins for applying contrasts{p_end}"
		.has_contrast = 0
		._drop_common_subopts
	}
end

program ._parse_pwcompare_opts
	if `.has_contrast' {
		di as err ///
"option pwcompare is not allowed with contrast operators"
		exit 198
	}
	capture ._get_common_subopts `0'
	if c(rc) {
		local rc = c(rc)
		di as err "invalid pwcompare() option;"
		._get_common_subopts `0'
		error `rc'	// [sic]
	}
	local 0 `", `s(options)'"'
	local OPTS	CIMargins		/// display opts
			GROUPs			///
						 // blank
	capture syntax [, `OPTS']
	if c(rc) {
		local rc = c(rc)
		di as err "invalid pwcompare() option;"
		syntax [, `OPTS']
		error `rc'	// [sic]
	}
	if `"`.mc_all'"' != "" & `"`groups'"' != "" {
		opts_exclusive "mcompare(`.mcall') pwcompare(`groups')"
	}

	.pwcompareopts = "`cimargins' `groups'"
end

program ._setup_pwcompare
	if `.has_pwcompare' == 0 {
		exit
	}

	if `.atrows' > 1 {
		._put_sharp `atcontrast'
		local prefix _at
		local sharp "#"
	}

	local over `"`.over'"'
	if `:length local over' {
		._put_sharp `over'
		local prefix `prefix'`sharp'`s(result)'
		local sharp "#"
	}

	local within `"`.within'"'
	if `:length local within' {
		._put_sharp `within'
		local prefix `prefix'`sharp'`s(result)'
		local sharp "#"
	}

	if `:length local prefix' {
		if `"`.umargins'"' == "" {
			.pwcompare = `"`prefix'"'
		}
		else {
			.pwcompare = `"`prefix'#(`.umargins')"'
		}
	}
	else {
		.pwcompare = `"`.umargins'"'
	}
	if `"`.pwcompare'"' == "" {
		di as txt ///
"{p 0 6 2}note: ignoring pwcompare options because there are no "	///
"margins for making pairwise comparisons{p_end}"
		.has_pwcompare = 0
		._drop_common_subopts
	}
end

program ._check_by_and_at
	local k_at	= `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'

	forval i = 1/`k_marg' {
		local mvars : colna `.mlist[`i']'
		local mlist `mlist' `mvars'
	}
	local mlist : list uniq mlist

	local over `"`.over'"'
	local common : list mlist & over
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor `x' not allowed in over() option if it is specified as a margin"
		exit 198
	}
	local within `"`.within'"'
	local common : list mlist & within
	if `:length local common' {
		gettoken x : common
		di as err ///
"factor `x' not allowed in within() option if it is specified as a margin"
		exit 198
	}

	if `k_marg' == 1 {
		local checkopt singlemargin
	}

	local k 0
	local noasobs 1
	forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		forval j = 1/`k_at' {
			local ++k
			.mstat[`k'] = ._marg_stat.new
			.mstat[`k'].set_parent	`.objkey'
			.mstat[`k'].set_at	`.atlist[`j']' `.atstat[`j']'
			.mstat[`k'].set_margin	`marg' `mlist'
			.mstat[`k'].check_at, `checkopt'
			if `noasobs' {
				local noasobs = r(noasobs)
			}
		}
	}
	.noasobs = `noasobs'
end

program ._check_exp, eclass
	syntax [if] [in] [fw iw pw aw] [, NOSE]

	tempname ehold b V
	_est hold `ehold', copy restore

	marksample t_if, novarlist zero
	local wgt "[`weight'`exp']"
	.compute `if' `in' `wgt', check
	scalar `b' = r(b)
	if r(constant) {
		di as txt ///
"{p 0 0 2}Warning: prediction constant over observations.{p_end}"
	}
	local n = r(N)
	sum `t_if' `wgt' if `t_if', mean
	if r(N) > `n' {
		di as err "{p 0 0 2}"
		di as err ///
"missing predicted values encountered within the estimation sample"
		di as err "{p_end}"
		exit 322
	}

	if `:length local nose' | `.e_marginsok' {
		exit
	}

	preserve

	// reset e(V) to identity matrix
	matrix `V' = e(V)
	matrix `V' = I(colsof(`V'))
	ereturn repost V=`V'

	// remove all non-integer scalars in e()
	local scalars : e(scalars)
	foreach s of local scalars {
		if e(`s') != floor(e(`s')) {
			ereturn local `s'
		}
	}

	// set all depvars to zero
	local vlist `"`e(depvar)'"'
	local vlist : list uniq vlist
	foreach var of local vlist {
		capture fvrevar `var', list
		if !c(rc) {
			capture replace `r(varlist)' = 0
		}
	}
	capture {
		.compute if `t_if' `wgt', check
		assert reldif(`b', r(b)) < 1e-12
	}
	if c(rc) {
		if `"`.oexp'"' != "" {
			if `.is_pred' {
				local msg0 "prediction"
			}
			else {
				local msg0 "expression"
			}
		}
		else {
			local msg0 "default prediction"
		}
		local msg1 ///
" is a function of possibly stochastic quantities other than e(b)"
		if `.force' {
			di as txt `"{p 0 7}(note: `msg0' `msg1'){p_end}"'
			exit
		}
		di as err `"{p}`msg0' `msg1'{p_end}"'
		exit 498
	}
end

// subroutines for .compute -------------------------------------------------

program .copyvar
	syntax [varname(default=none)] [, next rename zero]
	local next : length local next
	if `next' {
		local next = `.gen'
	}
	if `next' {
		local rename : length local rename
		local zero : length local zero
		local n = `.phat.arrnels' + 1
		local phat "`.t_phat'`n'"
		.phat[`n'] = "`phat'"
		if `zero' {
			quietly gen byte `phat' = 0
		}
		else if `rename' {
			rename `varlist' `phat'
		}
		else {
			quietly gen double `phat' = `varlist'
		}
	}
end

// subroutines for .estimate ------------------------------------------------

program ._make_group, sort
	local by `.t_sub' `.by'
	sort `by'
	quietly by `by': gen `.t_grp' = _n == 1 & `.t_sub'
	mata: st__marg_make_group("`.t_gmat'", "`.by'", "`.t_grp'")
	.k_by = rowsof(`.t_gmat')
	if `.k_by' > 1 {
		local nby = colsof(`.t_gmat')
		quietly replace `.t_grp' = sum(`.t_grp') if `.t_sub'
		local GVARS "`.by'"
		forval i = 1/`.k_by' {
			local stripe
			local cross
			local gvars : copy local GVARS
			forval j = 1/`nby' {
				gettoken gvar gvars : gvars
				local level = `.t_gmat'[`i',`j']
				local stripe `stripe'`cross'`level'.`gvar'
				local cross "#"
			}
			.bylist[`i'] = "`stripe'"
		}
	}
	else {
		.hasby = 0
		drop `.t_grp'
		matrix drop `.t_gmat'
	}
end

program ._fill_at
	local k_at = `.atlist.arrnels'
	local k_marg	= `.mlist.arrnels'
	local k 1
	forval i = 1/`k_marg' {
		local idx 0
		forval j = 1/`k_at'{
			.mstat[`k'].set_at_idx0 `idx'
			local idx = `idx' + rowsof(`.atlist[`j']')
			local ++k
		}
	}
	local r_at 0
	forval i = 1/`k_at' {
		local r_at = `r_at' + rowsof(`.atlist[`i']')
		.mstat[`i'].fill_at `.atlist[`i']'
		.atstat[`i'] = `"`.mstat[`i'].atstat'"'
	}
	.atrows = `r_at'
end

program ._linearize
	args p J V
	tempname sc D u v b b1

	local cmdname `"`e(cmd)'"'
	if "`cmdname'" == "cox" {
		local cmdname stcox
	}
	local cmdprops : properties `cmdname'
	local svylb svylb
	local allcons : list svylb in cmdprops
	if "`e(V_modelbased)'" == "matrix" {
		matrix `D' = e(V_modelbased)
	}
	else {
		if "`e(cmd)'" == "regress" {
			matrix `D' = e(V)/(e(rmse))^2
		}
		else {
			matrix `D' = e(V)
		}
	}
	local minus 1
	if "`e(cmd)'" == "regress" & !`.is_svy' {
		_ms_omit_info e(b)
		local minus = colsof(r(omit))
		if r(k_omit) {
			local minus = `minus' - r(k_omit)
		}
	}

	capture predict double `sc'*, scores
	if c(rc) {
		di as err "{p}cannot compute vce(unconditional);"
		di as err "predict after `e(cmd)' could not compute scores"
		di as err "{p_end}"
		exit 322
	}
	unab sclist : `sc'*
	local k_scores : list sizeof sclist
	local t_esub "`.t_esub'"
	if `:length local t_esub' {
		foreach s of local sclist {
			quietly replace `s' = 0 if !`t_esub'
		}
	}

	local dim = colsof(`p')
	matrix `v' = J(`dim', `dim', 0)
	local eq 0

	// build the list of subpop indicator variables

	if !`.hasby' {
		tempname touse2
		quietly gen byte `touse2' = `.t_sub'
	}

	local touse `.t_touse'
	local k_by = `.k_by'
	forval g = 1/`k_by' {
		tempname wdot`g'
		if `.hasby' {
			tempname sub`g'
			quietly gen byte `sub`g'' = `.t_grp' == `g'
		}
		else {
			local sub`g' : copy local touse2
		}
		sum `sub`g'' if `sub`g'' `.wt', mean
		scalar `wdot`g'' = r(sum_w)
		local slist `slist' `sub`g''
		local ++eq
		local stripe `stripe' `eq':_cons
	}

	// add the list of predictions

	if "`.xvars'" != "" {
		local xvars `"`.xvars'"'
	}
	else {
		local xvars _cons
	}

	local k_marg	= `.mlist.arrnels'
	local k_at	= `.atlist.arrnels'
	matrix `u' = J(`dim', `k_by', 0)
	local k 0
	foreach x of local xvars {
	    forval i = 1/`k_marg' {
		local marg `.mlist[`i']'
		local k_l = rowsof(`marg')
		forval j = 1/`k_at' {
		    local at `.atlist[`j']'
		    local r_at = rowsof(`at')
		    local g 1
		    forval r = 1/`r_at' {
			forval l = 1/`k_l' {
			    local ++k
			    local phat `.phat[`k']'
			    quietly replace `phat' = 0 if !`sub`g''
			    local slist `slist' `phat'
			    local ++eq
			    local stripe `stripe' `eq':_cons
			    matrix `u'[`k',`g'] = -`p'[1,`k']/`wdot`g''
			    matrix `v'[`k',`k'] = 1/`wdot`g''
			}
			if `.hasby' {
			    local g = mod(`g',`k_by') + 1
			}
		    }
		}
	    }
	}

	matrix `v' = `u', `v' , `J'*`D'

	// NOTE: For SRS designs '_robust2' assumes the variables are
	// centered at zero (an easy assumption to make for scores),
	// so we may need to center the variables.

	if `.is_svy' {
		quietly svyset
		local no_strata = "`r(strata1)'" == ""
		local no_psu = "`r(su1)'" == ""
		local stages = r(stages)
		local center = `stages' == 1
		if `center' {
			local center = `no_strata' & `no_psu'
		}
		local svy svy
	}
	else {
		local center = "`.clopt'" == ""
		local linwgt "`.wt'"
	}
	if `center' {
		local ulist : list uniq slist
		foreach u of local ulist {
			sum `u' if `.t_touse' `.wt', mean
			quietly replace `u' = `u' - r(mean)
		}
	}

	matrix `D' = I(colsof(`v'))

nobreak {

	local epilog "*"
	if `"`e(robust_prolog)'"' != "" {
		`e(robust_prolog)'
		local epilog `"`e(robust_epilog)'"'
	}

	matrix `b' = e(b)
	forval i = 1/`k_scores' {
		local ++eq
		if `allcons' {
			local stripe `stripe' `eq':_cons
		}
		else {
			matrix `b1' = `b'[1,"#`i':"]
			local cn`i' : colna `b1'
			foreach x of local cn`i' {
				local stripe `stripe' `eq':`x'
			}
		}
	}
	matrix colna `D' = `stripe'
	matrix rowna `D' = `stripe'

capture noisily break {

	_robust2 `slist' `sclist'		///
		if `.t_touse' `linwgt',		///
		v(`D')				///
		minus(`minus')			///
		`svy'				///
		`.clopt'

	if "`r(N_clust)'" != "" {
		.nclust = r(N_clust)
	}
	if `.is_svy' {
		.npsu	= r(N_clust)
		.nstr	= r(N_strata)
		.df_r	= r(df_r)
		if !missing(r(N_poststrata)) {
			.npost = r(N_poststrata)
		}
	}

} // capture noisily break
	local rc = c(rc)
	`epilog'

} // nobreak
	if `rc' {
		exit `rc'
	}

	matrix `V' = `v' * `D' * `v''
end

program ._est1_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_compute(`"`.objkey' `0'"')
end

program ._est1_db_cr
	syntax if/ [fw pw iw aw/] [, SCore(name) NONEXT]
	tempname ehold
	_est hold `ehold', copy restore
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	mata: st__marg_cr_compute(`"`.objkey' if `if' `wgt'"', "`.t_cr'")
end

program ._est2_c, rclass
	syntax if, xvar(string) [mult(passthru)]
	tempvar b nobs db

	if `.est_chk' {
		._check_est `if' `.wt', `mult'
		if r(not_estimable) {
			return add
			exit
		}
	}

	local xopt xvar(`xvar')

nobreak {

capture noisily break {

	if !`.cr_use' {
		tempvar hold
		rename `xvar' `hold'
		quietly gen double `xvar' = `hold'
	}
	else {
		.xvar = "1"
		._est2_c_cr `if'
	}

} // capture noisily break
	local rc = c(rc)

	if !`rc' {

capture noisily quietly break {

	.h	= 0
	.scale	= 0
	.xvar	= "`hold'"
	if `.cr_use' {
		_marg_dydx_ccompute_cr `.objkey' `if' `.wt', ///
			`xopt' `.nose' next
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		if `.se' {
			matrix `db' = r(db)
		}
	}
	else if "`.nose'" != "" {
		_marg_dydx_ccompute `.objkey' `if' `.wt', `xopt'
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		._est2_c_phat `if', `xopt' next
	}
	else {
		._est2_c_db `.objkey' `if' `.wt', `xopt'
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		matrix `db'	= r(db)
		._est2_c_phat `if', `xopt' next
	}

} // capture noisily quietly break
	local rc = c(rc)

	}

	if !`.cr_use' {
		capture drop `xvar'
		rename `hold' `xvar'
	}

} // nobreak 
	if `rc' {
		exit `rc'
	}

	return scalar b = `b'
	return scalar N = `nobs'
	if `.se' {
		return matrix db `db'
	}
end

program ._est2_c_cr
	syntax if

	capture drop `.t_dzb'*

	local cmd _est2_c_cr1
	if `.cr_use2' {
		local cmd _est2_c_cr2
	}

	local neq = rowsof(`.t_cr')
	tempname t
	local is_xb = `.is_xb' & !`.numeric'
	if `is_xb' {
		if `.ey' {
			.ey = 0
			.compute `if' `.wt', gen(`t')
			.ey = 1
			local vt_i 1/`t'
			local vt_ij -1/`t'^2
			local ttype double
		}
		else {
			local vt_i 1
			local vt_ij 0
			local ttype byte
		}
		local eqno = `.eqno'
	}
	forval i = 1/`neq' {
		local ti `.t_dzb'_`i'
		// dpdxb
		if !`is_xb' {
			quietly gen double `ti' = . in 1
		}
		else if `eqno' == `i' {
			quietly gen `ttype' `ti' = `vt_i'
		}
		else {
			quietly gen byte `ti' = 0
		}
		forval j = 1/`i' {
			// d2pdxbdxb
			local tij `.t_dzb'_`i'_`j'
			if !`is_xb' {
				quietly gen double `tij' = . in 1
			}
			else if `eqno' == `i' & `eqno' == `j' {
				quietly gen `ttype' `tij' = `vt_ij'
			}
			else {
				quietly gen byte `tij' = 0
			}
	
		}
	}
	if !`is_xb' {
		.`cmd' `.t_dzb' `if' `.wt'
	}
end

program ._est2_c_cr1
	tempname ehold
	_est hold `ehold', copy restore
	syntax name(name=t) [fw pw iw aw/] [if/]
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	local cr `.t_cr'
	mata: st__marg_dydx_cr_compute(`"`.objkey' if `if' `wgt'"', `.se')
end

program ._est2_c_cr2
	tempname ehold
	_est hold `ehold', copy restore
	syntax name(name=t) [fw pw iw aw/] [if/]
	if `:length local weight' {
		local wgt [`weight'=`exp']
	}
	local cr `.t_cr'
	mata: st__marg_dydx_cr2_compute(`"`.objkey' if `if' `wgt'"', `.se')
end

program ._est2_c_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_dydx_ccompute(`"`0'"')
end

program ._est2_c_phat
	syntax if, xvar(string) [next]

	local next : length local next
	if `next' & `.gen' {
		tempname d hold p1 p2
		scalar `d' = float(`.h'*`.scale')
		rename `xvar' `hold'
		quietly gen double `xvar' = `hold' - `d'
		.compute `if' `.wt', gen(`p1')
		quietly replace `xvar' = `hold' + `d'
		.compute `if' `.wt', gen(`p2')
		quietly replace `xvar' = (`p2' - `p1')/(2*`d')
		.copyvar `xvar', next rename
		rename `hold' `xvar'
	}
end

program ._est2_d, rclass
	syntax if, xvar(string) [mult(name)]
	tempvar b nobs db

	_ms_parse_parts `xvar'
	local var `r(name)'
	local k = r(level)
	.get_dx_base `var'
	if `k' == r(base) {
		scalar `b'	= 0
		scalar `nobs'	= 0
		if `:length local mult' {
			matrix `mult' = 0*e(b)
		}
		if `.se' {
			matrix `db' = 0*e(b)
		}
		.copyvar, next zero
	}
	else {
		._est2_d1 `0'
		if r(not_estimable)==1 {
			return add
			exit
		}
		scalar `b'	= r(b)
		scalar `nobs'	= r(N)
		if `.se' {
			matrix `db' = r(db)
		}
	}

	return scalar b = `b'
	return scalar N = `nobs'
	if `.se' {
		return matrix db `db'
	}
	return scalar not_estimable = 0
end

program ._est2_d1
	syntax if, xvar(passthru) [mult(passthru)]

	if `.est_chk' | !`.se' | `:length local mult' {
		if `.cr_use' | !`.se' {
			local next next
		}
		local estchk = cond(`.est_chk', "estimcheck", "")
		_marg_dydx_dcompute `.objkey' `if' `.wt', ///
			`xvar' `next' `mult' `estchk'
		if r(not_estimable) == 1 {
			exit
		}
	}
	if `.se' {
		if `.cr_use' {
			._est2_d1_db_cr `if' `.wt', `xvar' `mult'
		}
		else {
			._est2_d1_db `.objkey' `if' `.wt', `xvar'
		}
	}
end

program ._est2_d1_db_cr, rclass
	syntax [fw pw iw aw] [if], xvar(string)	[ mult(name) ]

	tempname p0 p1 n0 n1

	_ms_parse_parts `xvar'
	* xvar should NOT have tsops
	assert "`r(ts_op)'" == ""
	local var `r(name)'
	local k = r(level)
	.get_dx_base `var'
	local base = r(base)

	local BALVARS `"`.BALVARS'"'
	if `:length local BALVARS' {
		tempname mult0 mult1
		if "`.empty'" != "rweight" & `:length local mult' {
			local mult1 : copy local mult
		}
		local balopt balvars(`BALVARS')
	}
	if `.se' {
		tempname db0 db1
	}

	._compute1 `if' [`weight'`exp'], xvar(`var') k(`base')	///
		`balopt' mult(`mult0')
	scalar `p0' = r(b)
	scalar `n0' = r(N)
	if `.se' {
		matrix `db0' = r(db)
		if `:length local mult0' {
			mata: st_matrix("`db0'",	///
					st_matrix("`db0'") :* ///
					abs(st_matrix("`mult0'")))
		}
	}

	._compute1 `if' [`weight'`exp'], xvar(`var') k(`k')	///
		`balopt' mult(`mult1')
	scalar `p1' = r(b)
	scalar `n1' = r(N)
	if `.se' {
		matrix `db1' = r(db)
		if `:length local mult1' {
			mata: st_matrix("`db1'",	///
					st_matrix("`db1'") :* ///
					abs(st_matrix("`mult1'")))
		}
	}

	if `n0' != `n1' {
		di as err "{p}" ///
"inconsistent estimation sample levels `base' and `k' of factor `var'" ///
		"{p_end}"
		exit 459
	}

	return scalar b = `p1' - `p0'
	return scalar N = `n1'
	return scalar not_estimable = 0
	if `.se' {
		matrix `db1' = `db1' - `db0'
		return matrix db `db1'
	}
	if `:length local mult' & "`.empty'" == "reweight" {
		local c = colsof(`mult1')
		matrix `mult' = `mult1' - `mult0'
		forval i = 1/`c' {
			if `mult0'[1,`i'] == 1 {
				matrix `mult'[1,`i'] = 1
			}
		}
	}
end

program ._balance, eclass
	gettoken mult balvars : 0
	tempname b
	_ms_balance `balvars', `.empty'
	matrix `b' = r(b)
	ereturn repost b=`b', rename
	matrix `mult' = r(mult)
end

program ._compute1
	syntax [fw pw iw aw] [if],	///
		xvar(varname)					///
		k(integer)					///
		[	GENerate(passthru)			///
			mult(name)				///
			BALVARS(string)				///
		]
	local wgt [`weight'`exp']

	if `:length local balvars' {
		tempname ehold
		_est hold `ehold', copy restore
		._balance `mult' `balvars' `k'.`xvar'
	}

nobreak {

capture noisily break {

	tempvar hold
	rename `xvar' `hold'
	quietly gen `xvar' = `k'

} // capture noisily break
	local rc = c(rc)

	if !`rc' {

capture noisily quietly break {

		._est1_db_cr `if' `wgt', nonext

} // capture noisily quietly break
	local rc = c(rc)

	}

	capture confirm var `hold'
	if !c(rc) {
		capture drop `xvar'
		rename `hold' `xvar'
	}

} // nobreak
	exit `rc'
end

program ._est2_d1_db
	tempname ehold
	_est hold `ehold', copy restore
	mata: st__marg_dydx_dcompute(`"`0'"')
end

exit

Special considerations:

-margins- is aware of the following -e()- macros:

	e(wtype)	weight type
	e(wexp)		weight expression

	e(subpop)	subpopulation specification used to fit the -svy-
			model

	e(prefix)	check for "svy"

	e(vce)		VCE used by the estimation command
	e(vcetype)	VCE type reported above "Std. Err." in coef table

	e(clustvar)	cluster variable

	e(group)	identifies the cluster variable when
			-vce(unconditional)- option is specified, the model
			VCE type is "Robust", but there is nothing in
			-e(clustvar)-

	e(covariates)	list of covariate variables

	e(marginsprop)	signals to the -margins- command

	e(marginsok)	-predict- options certified to work with -margins-

	e(marginsok)	-predict- options certified NOT allowed with -margins-

-e(marginsprop)- signals:

	noeb		do not use -e(b)- for getting covariate term
			information or for restriping

	nochainrule	make -nochainrule- the default

